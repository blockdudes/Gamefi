var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { RestApi } from '@stardust-collective/dag4-core';
import { DNC } from '../../DNC';
export class BlockExplorerApi {
    constructor(host) {
        this.service = new RestApi(DNC.BLOCK_EXPLORER_URL);
        if (host) {
            this.config().baseUrl(host);
        }
    }
    config() {
        return this.service.configure();
    }
    getLatestSnapshot() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.$get('/snapshot/latest');
        });
    }
    getSnapshot(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.$get('/snapshot/' + id);
        });
    }
    getTransactionsBySnapshot(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.$get('/snapshot/' + id + '/transaction');
        });
    }
    getTransactionsByAddress(address, limit = 0, searchAfter = '', sentOnly = false, receivedOnly = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let params, path = '/address/' + address + '/transaction';
            if (limit || searchAfter) {
                params = {};
                if (limit > 0) {
                    params.limit = limit;
                }
                if (searchAfter) {
                    try {
                        new Date(searchAfter).toISOString();
                    }
                    catch (e) {
                        throw new Error('ParamError: "searchAfter" is not valid ISO 8601');
                    }
                    params.search_after = searchAfter;
                }
            }
            if (sentOnly) {
                path += '/sent';
            }
            else if (receivedOnly) {
                path += '/received';
            }
            return this.service.$get(path, params);
        });
    }
    getCheckpointBlock(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.$get('/checkpoint-block/' + hash);
        });
    }
    getTransaction(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.$get('/transaction/' + hash);
        });
    }
}
export const blockExplorerApi = new BlockExplorerApi();
//# sourceMappingURL=block-explorer-api.js.map