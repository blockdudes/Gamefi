var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { RestApi } from '@stardust-collective/dag4-core';
import { DNC } from '../../DNC';
import { PeerMetrics } from '../../dto/v1/peer-metrics';
export class LoadBalancerApi {
    constructor(host) {
        this.service = new RestApi(DNC.LOAD_BALANCER_URL);
        if (host) {
            this.config().baseUrl(host);
        }
    }
    config() {
        return this.service.configure();
    }
    getMetrics() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.$get('/metrics').then(rawData => PeerMetrics.parse(rawData.metrics, 0));
        });
    }
    getAddressBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.$get('/address/' + address);
        });
    }
    getAddressLastAcceptedTransactionRef(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.$get('/transaction/last-ref/' + address);
        });
    }
    getTotalSupply() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.$get('/total-supply');
        });
    }
    postTransaction(tx) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.$post('/transaction', tx);
        });
    }
    getTransaction(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.$get('/transaction/' + hash);
        });
    }
    checkTransactionStatus(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.service.$get('/transaction/' + hash);
            if (tx) {
                if (tx.cbBaseHash) {
                    return { accepted: true, inMemPool: false };
                }
                return { accepted: false, inMemPool: true };
            }
            return null;
        });
    }
    getClusterInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.$get('/cluster/info').then(info => this.processClusterInfo(info));
        });
    }
    getClusterInfoWithRetry() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.$get('/cluster/info', null, { retry: 5 }).then(info => this.retryClusterInfo(info));
        });
    }
    //Returns number of connected Nodes in Cluster
    activeNodeCount() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.service.$get('/utils/health');
        });
    }
    retryClusterInfo(info) {
        if (info && info.map) {
            return this.processClusterInfo(info);
        }
        else {
            return new Promise(resolve => {
                setTimeout(() => {
                    resolve(this.getClusterInfoWithRetry());
                }, 1000);
            });
        }
    }
    processClusterInfo(info) {
        return info && info.map && info.map(d => ({ alias: d.alias, walletId: d.id.hex, ip: d.ip.host, status: d.status, reputation: d.reputation }));
    }
}
export const loadBalancerApi = new LoadBalancerApi();
//# sourceMappingURL=load-balancer-api.js.map