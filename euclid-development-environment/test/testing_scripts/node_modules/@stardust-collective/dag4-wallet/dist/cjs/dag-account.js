"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DagAccount = void 0;
const dag4_keystore_1 = require("@stardust-collective/dag4-keystore");
const dag4_core_1 = require("@stardust-collective/dag4-core");
const dag4_network_1 = require("@stardust-collective/dag4-network");
const bignumber_js_1 = require("bignumber.js");
const rxjs_1 = require("rxjs");
const network_config_1 = require("./network-config");
const metagraph_token_client_1 = require("./metagraph-token-client");
class DagAccount {
    constructor(network) {
        this.sessionChange$ = new rxjs_1.Subject();
        this.network = network || dag4_network_1.globalDagNetwork;
    }
    connect(networkInfo, useDefaultConfig = true) {
        let baseConfig = {};
        if (useDefaultConfig && networkInfo.networkVersion) {
            const version = networkInfo.networkVersion.split(".")[0];
            const networkType = networkInfo.testnet ? "testnet" : "mainnet";
            baseConfig = network_config_1.networkConfig[version][networkType];
        }
        const networkId = networkInfo.id || "global";
        this.network.config(Object.assign(Object.assign(Object.assign({}, baseConfig), networkInfo), { id: networkId }));
        return this;
    }
    get address() {
        const address = this.m_keyTrio && this.m_keyTrio.address;
        if (!address) {
            throw new Error("Need to login before calling methods on dag4.account");
        }
        return address;
    }
    get keyTrio() {
        return this.m_keyTrio;
    }
    get publicKey() {
        return this.m_keyTrio.publicKey;
    }
    get networkInstance() {
        return this.network;
    }
    loginSeedPhrase(words) {
        const privateKey = dag4_keystore_1.keyStore.getPrivateKeyFromMnemonic(words);
        this.loginPrivateKey(privateKey);
    }
    loginPrivateKey(privateKey) {
        const publicKey = dag4_keystore_1.keyStore.getPublicKeyFromPrivate(privateKey);
        const address = dag4_keystore_1.keyStore.getDagAddressFromPublicKey(publicKey);
        this.setKeysAndAddress(privateKey, publicKey, address);
    }
    loginPublicKey(publicKey) {
        const address = dag4_keystore_1.keyStore.getDagAddressFromPublicKey(publicKey);
        this.setKeysAndAddress("", publicKey, address);
    }
    isActive() {
        return !!this.m_keyTrio;
    }
    logout() {
        this.m_keyTrio = null;
        this.sessionChange$.next(true);
    }
    observeSessionChange() {
        return this.sessionChange$;
    }
    setKeysAndAddress(privateKey, publicKey, address) {
        this.m_keyTrio = new dag4_keystore_1.KeyTrio(privateKey, publicKey, address);
        this.sessionChange$.next(true);
    }
    getTransactions(limit, searchAfter) {
        return this.network.getTransactionsByAddress(this.address, limit, searchAfter);
    }
    validateDagAddress(address) {
        return dag4_keystore_1.keyStore.validateDagAddress(address);
    }
    getBalance() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getBalanceFor(this.address);
        });
    }
    getBalanceFor(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const addressObj = yield this.network.getAddressBalance(address);
            if (addressObj && !isNaN(addressObj.balance)) {
                return new bignumber_js_1.BigNumber(addressObj.balance)
                    .multipliedBy(dag4_core_1.DAG_DECIMALS)
                    .toNumber();
            }
            return 0;
        });
    }
    getFeeRecommendation() {
        return __awaiter(this, void 0, void 0, function* () {
            //Get last tx ref
            const lastRef = (yield this.network.getAddressLastAcceptedTransactionRef(this.address));
            const hash = lastRef.prevHash || lastRef.hash; // v1 vs v2 format
            if (!hash) {
                return 0;
            }
            //Check for pending TX
            const lastTx = yield this.network.getPendingTransaction(hash);
            if (!lastTx) {
                return 0;
            }
            return 1 / dag4_core_1.DAG_DECIMALS;
        });
    }
    generateSignedTransaction(toAddress, amount, fee = 0, lastRef) {
        return __awaiter(this, void 0, void 0, function* () {
            lastRef = lastRef
                ? lastRef
                : yield this.network.getAddressLastAcceptedTransactionRef(this.address);
            if (this.network.getNetworkVersion() === "2.0") {
                return dag4_keystore_1.keyStore.generateTransactionV2(amount, toAddress, this.keyTrio, lastRef, fee);
            }
            // Support old and new lastRef format
            if (lastRef && lastRef.hash && !lastRef.prevHash) {
                lastRef.prevHash = lastRef.hash;
            }
            return dag4_keystore_1.keyStore.generateTransaction(amount, toAddress, this.keyTrio, lastRef, fee);
        });
    }
    generateSignedTransactionWithHash(toAddress, amount, fee = 0, lastRef) {
        return __awaiter(this, void 0, void 0, function* () {
            lastRef = lastRef
                ? lastRef
                : yield this.network.getAddressLastAcceptedTransactionRef(this.address);
            if (this.network.getNetworkVersion() === "2.0") {
                return dag4_keystore_1.keyStore.generateTransactionWithHashV2(amount, toAddress, this.keyTrio, lastRef, fee);
            }
            // Support old and new lastRef format
            if (lastRef && lastRef.hash && !lastRef.prevHash) {
                lastRef.prevHash = lastRef.hash;
            }
            return dag4_keystore_1.keyStore.generateTransactionWithHash(amount, toAddress, this.keyTrio, lastRef, fee);
        });
    }
    transferDag(toAddress, amount, fee = 0, autoEstimateFee = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let normalizedAmount = Math.floor(new bignumber_js_1.BigNumber(amount).multipliedBy(dag4_core_1.DAG_DECIMALS).toNumber());
            const lastRef = yield this.network.getAddressLastAcceptedTransactionRef(this.address);
            if (fee === 0 && autoEstimateFee) {
                const tx = yield this.network.getPendingTransaction(lastRef.prevHash || lastRef.hash);
                if (tx) {
                    const addressObj = yield this.network.getAddressBalance(this.address);
                    //Check to see if sending max amount
                    if (addressObj.balance === normalizedAmount) {
                        amount -= dag4_core_1.DAG_DECIMALS;
                        normalizedAmount--;
                    }
                    fee = dag4_core_1.DAG_DECIMALS;
                }
            }
            const tx = yield this.generateSignedTransaction(toAddress, amount, fee);
            const txHash = yield this.network.postTransaction(tx);
            if (txHash) {
                return {
                    timestamp: Date.now(),
                    hash: txHash,
                    amount: amount,
                    receiver: toAddress,
                    fee,
                    sender: this.address,
                    ordinal: lastRef.ordinal,
                    pending: true,
                    status: "POSTED",
                };
            }
        });
    }
    waitForCheckPointAccepted(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            // In V2 the txn is accepted as it's processed so we don't need to check multiple times
            if (this.network.getNetworkVersion() === "2.0") {
                let txn;
                try {
                    txn = (yield this.network.getPendingTransaction(hash));
                }
                catch (err) {
                    // 404 NOOP
                }
                if (txn && txn.status === "Waiting") {
                    return true;
                }
                try {
                    yield this.network.getTransaction(hash);
                }
                catch (err) {
                    // 404s if not found
                    return false;
                }
                return true;
            }
            let attempts = 0;
            for (let i = 1;; i++) {
                const result = yield this.network.loadBalancerApi.checkTransactionStatus(hash);
                if (result) {
                    if (result.accepted) {
                        break;
                    }
                }
                else {
                    attempts++;
                    if (attempts > 20) {
                        throw new Error("Unable to find transaction");
                    }
                }
                yield this.wait(2.5);
            }
            return true;
        });
    }
    waitForBalanceChange(initialValue) {
        return __awaiter(this, void 0, void 0, function* () {
            if (initialValue === undefined) {
                initialValue = yield this.getBalance();
                yield this.wait(5);
            }
            let changed = false;
            //Run for a max of 2 minutes (5 * 24 times)
            for (let i = 1; i < 24; i++) {
                const result = yield this.getBalance();
                if (result !== undefined) {
                    if (result !== initialValue) {
                        changed = true;
                        break;
                    }
                }
                yield this.wait(5);
            }
            return changed;
        });
    }
    wait(time = 5) {
        return new Promise((resolve) => setTimeout(resolve, time * 1000));
    }
    // 2.0+ only
    generateBatchTransactions(transfers, lastRef) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.network.getNetworkVersion() === "1.0") {
                throw new Error("transferDagBatch not available for mainnet 1.0");
            }
            if (!lastRef) {
                lastRef = (yield this.network.getAddressLastAcceptedTransactionRef(this.address));
            }
            const txns = [];
            for (const transfer of transfers) {
                const { transaction, hash } = yield this.generateSignedTransactionWithHash(transfer.address, transfer.amount, transfer.fee, lastRef);
                lastRef = {
                    hash,
                    ordinal: lastRef.ordinal + 1,
                };
                txns.push(transaction);
            }
            return txns;
        });
    }
    sendBatchTransactions(transactions) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.network.getNetworkVersion() === "1.0") {
                throw new Error("transferDagBatch not available for mainnet 1.0");
            }
            const hashes = [];
            for (const txn of transactions) {
                const hash = yield this.network.postTransaction(txn);
                hashes.push(hash);
            }
            return hashes;
        });
    }
    transferDagBatch(transfers, lastRef) {
        return __awaiter(this, void 0, void 0, function* () {
            const txns = yield this.generateBatchTransactions(transfers, lastRef);
            return this.sendBatchTransactions(txns);
        });
    }
    createMetagraphTokenClient(networkInfo) {
        return new metagraph_token_client_1.MetagraphTokenClient(this, networkInfo);
    }
}
exports.DagAccount = DagAccount;
//# sourceMappingURL=dag-account.js.map